# base

snippet p "package" !b
package ${1:main}
endsnippet

snippet f "function" !b
func ${1:name}(${2:args}) ${3: }{
	$4
}
endsnippet

snippet s "struct" !b
type ${1:name} struct {
	$2
}
endsnippet

# types

snippet st "string"
string
endsnippet

snippet b "bool"
bool
endsnippet

snippet msi "map[string]interface{}"
map[string]interface{}
endsnippet

snippet in "interface{}"
interface{}
endsnippet

# iterators

snippet fs "slice for" !b
for _, ${1:element} := range ${2:slice} {
	$0
}
endsnippet

snippet fl "loop for" !b
for {
	$0
}
endsnippet

snippet fi "times for" !b
for i := 0; i < ${1:iterations}; i++ {
	$0
}
endsnippet

# conditional

snippet e "if err != nil" !b
if err != nil {
	${1:return err}
}
$0
endsnippet

snippet sw "switch" !b
switch ${1:variable} {
case $2:
	$0
}
endsnippet

snippet swt "switch type" !b
switch ${1:variable}.(type) {
case $2:
	$0
}
endsnippet

# logging

snippet li "log.Info" !b
log.Info("%#v", $0)
endsnippet

snippet lf "log.Fatal" !b
log.Fatal($0)
endsnippet

snippet ln "log.Notice" !b
log.Notice("%v", ${0:variable})
endsnippet

snippet dbg "log.Printf()" !b
log.Printf("!!! %#v\n", $0)
endsnippet

snippet vl "var log"
var log = logging.MustGetLogger("$0")
endsnippet

# tricky ones

snippet tf "func (type)" !b
func (${1/.*([A-Z0-9]|\W)([a-z0-9]+([A-Z0-9]|$))/\l$1$2/} ${1:Type}) ${2:FuncName}($3)${4: }{
	$0
}
endsnippet

# vim-pythonx powered

global !p
import go
endglobal

snippet i "if"
if ${1:`!p snip.rv=go.get_last_var_for_snippet()`} {
	${2:${VISUAL}}
}
endsnippet

snippet r "return" !b
return ${1:`!p snip.rv=go.get_last_var_for_snippet()`}
endsnippet
