snippet pm "package main" b
package main
endsnippet

snippet f "function" b
func ${1:main}(${2:args}) $3 {
	$0
}
endsnippet

snippet gof "go anonymous func"
go func() {
	$1
}()
endsnippet

snippet ms "make slice" w
make([]$1, ${2:0})
endsnippet

snippet mc "make chan" w
make(chan $1, ${2:0})
endsnippet

snippet mm "make map" w
make(map[${1:string}]${2:interface\{\}})
endsnippet

snippet s "string"
string
endsnippet

snippet b "bool"
bool
endsnippet

snippet msi "map[string]interface{}"
map[string]interface{}
endsnippet

snippet in "interface{}"
interface{}
endsnippet

snippet ve "var err error"
var err error
endsnippet

snippet st "struct" b
type ${1:name} struct {
	$0
}
endsnippet

snippet ti "type interface" b
type ${1:name} interface {
	$0
}
endsnippet

snippet v "var" b
var ${1:variable} ${2:type}
endsnippet

snippet fl "loop for" b
for {
	$1
}
endsnippet

snippet fi "times for" b
for index := 0; index < ${1:iterations}; index++ {
	$2
}
endsnippet

snippet swt "switch type" b
switch ${1:variable}.(type) {
	$2
}
endsnippet

snippet c "case" b
case $1:
	$2
endsnippet

snippet li "log.Info" b
log.Info("%#v", $1)
endsnippet

snippet lf "log.Fatal" b
log.Fatal($1)
endsnippet

snippet ln "log.Notice" b
log.Notice("%v", ${1:`!p snip.rv=px.all.get_last_var_for_snippet()`})
endsnippet

snippet lp "log.Printf()" b
log.Printf("!!! %#v\n", $1)
endsnippet

snippet vl "var log"
var log = logging.MustGetLogger("$1")
endsnippet

snippet fm "fmt.Print" b
fmt.Print$1($2)
endsnippet

snippet tf "func (type)" b
func (${1/.*([A-Z0-9]|\W)([a-z0-9]+([A-Z0-9]|$))/\l$1$2/} ${1:Type}) ${2:FuncName}($3)${4: }{
	$0
}
endsnippet

snippet sf "struct field with json notation"
${1:fieldName} ${2:fieldType} \`${3:json}:"${1/(.*)/\l$1/}"\`
endsnippet

snippet oe "os.Exit()"
os.Exit(${1:0})
endsnippet

snippet rn "return nil"
return nil
endsnippet

snippet ife "if err != nil"
if err != nil {
	return $1, err
}
endsnippet

snippet "return n" "return nil" bw
return nil
endsnippet

global !p
import px.go
endglobal

snippet p "panic" "re.match('^\s+if err ', px.util.get_prev_nonempty_line(snip.buffer, snip.line))" bwe
panic(err)
endsnippet

snippet lf "log.Fatal(err)" "re.match('^\s+if err ', px.util.get_prev_nonempty_line(snip.buffer, snip.line))" bwe
log.Fatal(err)
endsnippet

snippet p "package" "snip.line == 1" bwe
package ${1:`!p snip.rv=px.go.guess_package_name_from_file_name(snip.fn)`}

$0
endsnippet

snippet i "if" bA
if ${1:`!p snip.rv=px.all.get_last_var_for_snippet()`} $2 {
	${3:${VISUAL}}
}
endsnippet

snippet r "return" b
return ${1:`!p snip.rv=px.all.get_last_var_for_snippet()`}
endsnippet

snippet r "return" "re.match('^\s+if err ', px.util.get_prev_nonempty_line(snip.buffer, snip.line))" eb
return err
endsnippet

snippet a "append"
append(${1:`!p snip.rv=px.all.get_last_var_for_snippet()`})
endsnippet

snippet fr "for range" b
for _, ${1:element} := range ${2:`!p snip.rv=px.all.get_last_var_for_snippet()`} {
	$3
}
endsnippet

snippet sw "switch" b
switch ${1:`!p snip.rv=px.all.get_last_var_for_snippet()`} {
case $2:
	$0
}
endsnippet

snippet i "integer field" "px.go.is_func_declaration(snip.buffer, snip.line)" we
$1 int,
endsnippet

snippet m "map field" "px.go.is_type_declaration(snip.buffer, snip.line)" bwe
$1 map[${2:string}]${3:interface{}}
endsnippet

snippet args "args init"
args, _ := docopt.Parse(usage, nil, true, "1.0", false)
endsnippet

snippet . "$1 = $2" bA
$1 = $2
endsnippet

snippet atoi "string to integer"
${1}, _ := strconv.Atoi(${2:`!p snip.rv=px.all.get_last_var_for_snippet()`})
endsnippet

snippet tss "time.sleep(time.Second)"
time.sleep(time.Second)
endsnippet
